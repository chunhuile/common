# js方面的面试题
1、js的数据类型
        js的数据类型有6种：基本类型：number、string、boleean、null、undefined
            引用类型：object（对象）和array(数组)
            es6新增：symbol(虚值)、bigint（无限大的整数）
    null和undefined的区别
        null是已经明确值的值，不代表任何值
        undefined是未指定值的变量的默认的值（未定义的值）
        函数没有写返回值，即没有return，这时候获取的便是undefined
        null表示空对象，也作为对象原型链的终点
        null会作为初始值，用于一些可能返回对象的变量
    数据类型存储以及堆栈是什么
        基本数据类型：直接存储在栈内存中，占据空间小，大小也固定，属于频繁使用的数据。指的是保存在栈内存中的简单数据段：number string、boolean
        引用数据：类型将指针存在栈中，将值存在堆中。 当我们把对象值赋值给另外一个变量时，复制的是对象的指针，指向同一块内存地址，意思是，变量中保存的实际上只是一个指针，这个指针指向内存堆中实际的值，数组 对象

    堆（heap）和栈（stack）有什么区别
        栈： 是一种连续储存的数据结构，具有先进后出后进先出的性质。
        通常的操作有入栈（压栈），出栈和栈顶元素。想要读取栈中的某个元素，就是将其之间的所有元素出栈才能完成。

        堆：是一种非连续的树形储存数据结构，具有队列优先,先进先出； 每个节点有一个值，整棵树是经过排序的。特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。常用来实现优先队列，存取随意。

    es10新增：bigInt表示任意大的整数
        BigInt数据类型的目的是比Number数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用BigInt，整数溢出将不再是问题。

        此外，可以安全地使用更加准确时间戳，大整数ID等，而无需使用变通方法。 BigInt目前是第3阶段提案， 一旦添加到规范中，它就是JS 第二个数字数据类型，也将是 JS 第8种基本数据类型：
        要创建BigInt，只需在整数的末尾追加n即可。比较:
            console.log(9007199254740995n);    // → 9007199254740995n
            console.log(9007199254740995);     // → 9007199254740996
            ​
            或者，可以调用BigInt()构造函数
            BigInt("9007199254740995");    // → 9007199254740995n
            ​
            // 注意最后一位的数字
            9007199254740992 === 9007199254740993;    // → true
            console.log(9999999999999999);    // → 10000000000000000

2、js数据类型判断，条件分支
    if语句和逻辑运算符
        略
    逻辑运算符以及他们的运算规则
        略
    js的数据类型判断
        typeof 、object.instanceof、constructor、以及object.prototype.toString.call()
    数据类型转换
        +是将字符串转为数字
        .toString（）、string是将数字转为字符串

        注意：null和undefined没有toString()方法
    数据类型相比较 obeect.is ==  和===
        === 属于严格判断，直接判断两者类型是否相同，如果两边的类型不一致时，不会做强制类型准换，不同则返回false如果相同再比较大小，不会进行任何隐式转换对于引用类型来说，比较的都是引用内存地址，所以===这种方式的比较，除非两者存储的内存地址相同才相等，反之false

        == 二等表示值相等。判断操作符两边对象或值是否相等类型可以不同，如果两边的类型不一致，则会进行强制类型转化后再进行比较，使用Number()转换成Number类型在进行判断。例外规则，null==undefined，null/undefined进行运算时不进行隐式类型转换。通常把值转为Boolean值，进行条件判断。Boolean(null)===Boolean(undefined)>false===false 结果为true

        Object.is()在===基础上特别处理了NaN,-0,+0,保证-0与+0不相等，但NaN与NaN相等

    typeof null的结果是，以及为什么
        object

        在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：

            000: object   - 当前存储的数据指向一个对象。
            1: int      - 当前存储的数据是一个 31 位的有符号整数。
            010: double   - 当前存储的数据指向一个双精度的浮点数。
            100: string   - 当前存储的数据指向一个字符串。
            110: boolean  - 当前存储的数据是布尔值。
        有两种特殊数据类型：

            undefined的值是 (-2)30(一个超出整数范围的数字)；

            null 的值是机器码 NULL 指针(null 指针的值全是 0)

        那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。

3、事件的故事
    什么是事件
        事件是文档和浏览器窗口中发生的特定的交互瞬间，事件就发生了。
        一是直接在标签内直接添加执行语句，
        二是定义执行函数。
        addeventlistener 监听事件
        事件类型分两种：事件捕获、事件冒泡。
        事件捕获就是：网景公司提出的事件流叫事件捕获流，由外往内，从事件发生的顶点开始，逐级往下查找，一直到目标元素。
        事件冒泡：IE提出的事件流叫做事件冒泡就是由内往外，从具体的目标节点元素触发，逐级向上传递，直到根节点。
        什么是事件流?
        事件流就是，页面接受事件的先后顺序就形成了事件流。
        自定义事件
        自定义事件，就是自己定义事件类型，自己定义事件处理函数。

    什么是事件委托
        事件委托，又名事件代理。事件委托就是利用事件冒泡，就是把子元素的事件都绑定到父元素上。如果子元素阻止了事件冒泡，那么委托也就没法实现了阻止事件冒泡event.stopPropagation() .stop修饰符
        addEventListener(‘click',函数名,true/false) 默认值为false（即 使用事件冒泡）true 事件捕获

        好处：提高性能，减少了事件绑定，从而减少内存占用
        应用场景 在vue中事件委托：
            我们经常遇到vue中v-for一个列表，列表的每一项都绑定了@click处理事件。我们都知道绑定这么多监听，从性能方面来说是不太好的。那我们我们可以通过把每个item的click事件委托给父元素的形式来实现

    封装事件绑定
        我们在封装这个函数的时候可以用addEventListener(事件监听)来实现 ，封装的函数有三个参数，第一个是要绑定事件的元素，第二个是要绑定的事件类型，第三个是事件的执行函数。 调用这个函数 就可以实现给某个元素绑定一个事件了。
    js的作用域和作用域链
        作用域： 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。简单说：函数内部局部作用域，函数外面全局作用域。
        
        作用域就是一个变量可以使用的范围，主要分为全局作用域和函数作用域
        全局作用域就是Js中最外层的作用域，在哪里都可以访问
        函数作用域是js通过函数创建的一个独立作用域，只能在函数内部访问，函数可以嵌套，所以作用域也可以嵌套
        Es6中新增了块级作用域（由大括号包裹，比如：if(){},for(){}等）
    防抖节流
        防抖：所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

        节流：所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。两种方式可以实现，分别是时间戳版和定时器版。     

    鼠标事件mouseenter与mouseover的区别
        mouseenter： 鼠标进入被绑定事件监听元素节点时触发一次，再次触发是鼠标移出被绑定元素，再次进入时。而当鼠标进入被绑定元素节点触发一次后没有移出，即使鼠标动了也不再触发。
        mouseover： 鼠标进入被绑定事件监听元素节点时触发一次，如果目标元素包含子元素，鼠标移出子元素到目标元素上也会触发。

        mouseenter 不支持事件冒泡 mouseover 会冒泡

4、引用数据类型object
    object的方法
        参考base/objec.js
    对象和面向对象
        对象：属性和方法的集合叫做对象（万物皆对象）。

        面向对象：首先就是找对象，如果该对象不具备所需要的方法或属性，那就给它添加。 面向对象是一种编程思维的改变。通过原型的方式来实现面向对象编程。

        创建对象的方式(4种)：new Object、字面量、构造函数、原型。
    什么是深拷贝，浅拷贝，两者的区别
        略

5、数组
    数组的方法
        略
    检测数组的方法
        object.protype.toString.call()、typeOf、instanceOf、array.is
    数组的高阶函数
        filter、forEach、reduce、map
6、字符串
    字符串的方法
        略
    超长字符串存储到栈内存中
        字符串属于基础类型，所以会觉得字符串是存在栈内存中的，但是要知道，V8默认栈内存是984Kib，那如果一个超长字符串 > 984Kib能装的进栈内存吗？

        字符串的内容存于堆内存中，指针存于栈内存中，且相同的字符串指向同一个堆内存地址

        新增或者修改字符串后，如果是一个之前不存在的字符串，则新开辟内存空间，如果是已有的，则直接使用已有的内存空间

        当我们新建一个字符串时，V8会从内存中查找一下是否已经有存在的一样的字符串，找到的话直接复用。如果找不到的话，则开辟一块新的内存空间来存这个字符串，并把地址赋给变量。

7、js函数
        略
    立即执行函数（life）和使用场景
        立即执行函数：( function( ){ })( ) 返回值可以为基本数据类型，也能返会任何类型的值。

        写法原因：因为在 javascript 里，括号内部不能包含语句，当解析器对代码进行解释的时候，先碰到了()， 然后碰到function关键字就会自动将()里面的代码识别为函数表达式而不是函数声明。

        作用：立即执行函数会形成一个单独的作用域，我们可以封装一些临时变量或者局部变量，避免污染全局变量。

        使用场景： ①代码在页面加载完成之后，不得不执行一些设置工作，比如时间处理器，创建对象等等。 ②所有的这些工作只需要执行一次，比如只需要显示一个时间。

        ③需要一些临时的变量，但是初始化过程结束之后，就再也不会被用到，我们可以用立即执行函数——去将我们所有的代码包裹在它的局部作用域中， 不会让任何变量泄露成全局变量。

    arguments的对象是什么
    this的指向（高频）
        略
    函数编程式含义：
        闭包
        call、bind、apply
            略
        函数柯里化函数例子
            略
        什么是高阶函数
            略
    构造函数
        new的原理
            new实际上是在堆内存中开辟一个空间。
                ①创建一个空对象，构造函数中的this指向这个空对象；
                ②这个新对象被执行[ [ 原型 ] ]连接；
                ③执行构造函数方法，属性和方法被添加到this引用的对象中；
                ④如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。
​
                    function _new(){
                        let target = {};   //创建的新对象
                        let [constructor,...args] = [...arguments];
                        //执行[[原型]]连接,target是constructor的实例
                        target.__proto__ = constructor.prototype;
                            //执行构造函数,将属性或方法添加到创建的空对象上
                        let result = constructor.prototype;
                        if(result && (typeof (result) == "object" || typeof (result) == "function")){
                            //如果构造函数执行的结构返回的是一个对象,那么返回这个对象
                            return result;
                        }
                        //如果构造函数返回的不是一个对象,返回创建的对象
                        return target;
                    }
​
        ​
            自己理解的new：         
                new实际上是在堆内存中开辟一个新的空间。首先创建一个空对象obj，然后呢，
                把这个空对象的原型(__proto__)和构造函数的原型对象(constructor.prototype)连接(说白了就是等于)；
                然后执行函数中的代码，就是为这个新对象添加属性和方法。最后进行判断其返回值，如果构造函数返回的是一个对象，
                那就返回这个对象，如果不是，那就返回我们创建的对象。

        封装一个通用的事件绑定函数作用域、js机制
            需要点击每个a，来。弹出他们的内容
                <div id="div3">
                    <a href="#">a1</a><br>
                    <a href="#">a2</a><br>
                    <a href="#">a3</a><br>
                    <a href="#">a4</a><br>
                    <button id='btn1'>加载更多...</button>
                </div>
                // 封装通用的事件绑定函数
                function bindEvent(elem, type, fn) {
                    elem.addEventListener(type, fn)
                }
                //获取父元素
                const fu = document.getElementById('div3')
                bindEvent(fu, 'click', function (event) {
                    // console.log(event.target) // 获取触发的元素
                    let target=event.target
                    event.preventDefault() // 阻止默认行为
                    //过滤符合条件的子元素，主要是过滤掉 加载更多 
                    if(target.nodeName.toLowerCase()==="A"){
                        alert(target.innerHTML;
                    }
                })
        垃圾回收机制和内存机制
            垃圾回收
                浏览器的js具有自动垃圾回收机制，垃圾回收机制也就是自动内存管理机制，垃圾收集器会定期的找出那些不在继续使用的变量，然后释放内存。但是这个过程不是实时的，因为GC开销比较大并且时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。

            内存泄露
                如果 那些不再使用的变量，它们所占用的内存 不去清除的话就会造成内存泄漏
                内存泄露其实就是我们的程序中已经动态分配的堆内存，由于某些原因没有得到释放，造成系统内存的浪费导致程序运行速度减慢甚至系统崩溃等严重后果。
                比如说：
                    1、闭包：在闭包中引入闭包外部的变量时，当闭包结束时此对象无法被垃圾回收（GC）。
                    2、DOM：当原有的DOM被移除时，子结点引用没有被移除则无法回收
                    3、Times计时器泄露
        作用域
            略
        谈谈js的运行机制
            1. js单线程

J           avaScript语言的一大特点就是单线程，即同一时间只能做一件事情。

            2. js事件循环

            js代码执行过程中会有很多任务，这些任务总的分成两类：
            同步任务
            异步任务
            需要注意的是除了同步任务和异步任务，任务还可以更加细分为macrotask(宏任务)和microtask(微任务)，js引擎会优先执行微任务

            微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。
            ​
            宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲
            染等。
            首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。

            在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务

            当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。

            任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。

            当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。

            最后可以用下面一道题检测一下收获：

            setTimeout(function() {
            console.log(1)
            }, 0);
            new Promise(function(resolve, reject) {
            console.log(2);
            resolve()
            }).then(function() {
            console.log(3)
            });
            process.nextTick(function () {
            console.log(4)
            })
            console.log(5)
            第一轮：主线程开始执行，遇到setTimeout，将setTimeout的回调函数丢到宏任务队列中，在往下执行new Promise立即执行，输出2，then的回调函数丢到微任务队列中，再继续执行，遇到process.nextTick，同样将回调函数扔到为任务队列，再继续执行，输出5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和nextTick两个微任务，先执行哪个呢？process.nextTick指定的异步任务总是发生在所有异步任务之前，因此先执行process.nextTick输出4然后执行then函数输出3，第一轮执行结束。

            第二轮：从宏任务队列开始，发现setTimeout回调，输出1执行完毕，因此结果是25431

        js延迟加载的方式

            JavaScript 是单线程（js不走完下面不会走是因为同步）会阻塞DOM的解析，因此也就会阻塞DOM的加载。所以有时候我们希望延迟JS的加载来提高页面的加载速度。
                1.把JS放在页面的最底部
                2.script标签的defer属性：脚本会立即下载但延迟到整个页面加载完毕再执行。该属性对于内联脚本无作用 (即没有 「src」 属性的脚本）。
                3.是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行，标记为async的脚本并不保证按照指定他们的先后顺序执行， 该属性对于内联脚本无作用 (即没有 「src」 属性的脚本）。
                4.动态创建script标签，监听dom加载完毕再引入js文件

        宏任务和微任务
            js中的一个机制，就是遇到宏任务，先将宏任务放入eventqueue，然后在执行微任务。
                宏任务：setTimeout,setInterval,Ajax,DOM事件
                微任务：Promise async/await
                想明白这个机制 就要理解js单线程。因为JS是单线程语言，只能同时做一件事儿。js任务需要排队顺序执行，如果一个任务时间过长，后边的任务也会等着。假如，我们在请求一个网址时，图片加载很慢，网页总不能一直卡不出来，

                这个时候就可以用异步来解决了，异步的特点不会阻塞代码的执行 ,解决了单线程等待的这个问题

                在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务

                异步和单线程是相辅相成的，js是一门单线程语言，所以需要异步来辅助。
            宏任务macrotask： 可以理解是每次执行栈执行的代码就是一个宏任务(包括每次从事件队列中获取一个事件回调并放到
            执行栈中执行)。
            常见的宏任务：script, setTimeout, setInterval, setImmediate, I/O, UI rendering。
            
            微任务microtask(异步)： 可以理解是在当前task执行结束后立即执行的任务。
            ​
            常见的微任务：process.nextTick(Nodejs),Promise.then(), MutationObserver。
            ​
            线程，进程?
            线程是最小的执行单元，进程是最小的资源管理单元一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程
            内存泄露

            如果 那些不再使用的变量，它们所占用的内存 不去清除的话就会造成内存泄漏

            比如说：

            1、闭包：在闭包中引入闭包外部的变量时，当闭包结束时此对象无法被垃圾回收（GC）。

            2、DOM：当原有的DOM被移除时，子结点引用没有被移除则无法回收

            3、Times计时器泄露

        js预解析（变量提升），它导致了什么问题

            JS代码在执行前，浏览器会对js代码进行扫描，默认的把所有带var和function声明的变量进行提前的声明或者定义，遵循先解析后使用的原则。 变量提升的表现是，在变量或函数声明之前访问变量或调用函数而不会报错。

            原因 JavaScript引擎在代码执行前有一个解析的过程（预编译），创建执行上线文，初始化一些代码执行时需要用到的对象。 当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性， 它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。

            首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。

            1.在解析阶段 JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来， 变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似， 不过函数执行上下文会多出this、arguments和函数的参数。

            全局上下文：变量定义，函数声明 函数上下文：变量定义，函数声明，this，arguments

            2.在执行阶段，就是按照代码的顺序依次执行。

            那为什么会进行变量提升呢？主要有以下两个原因：
            
            1、提高性能
            2、容错性更好
            ​
            （1）提高性能 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，
                那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。
                
                在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、
                不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），
                并且因为代码压缩的原因，代码执行也更快了。
                
            （2）容错性更好 变量提升可以在一定程度上提高JS的容错性，看下面的代码：
            ​
                a = 1
                var a
                console.log(a) //1
                如果没有变量提升，这段代码就会报错导致的问题
            var tmp = new Date();
            ​
            function fn(){
                console.log(tmp);
                if(false){
                    var tmp = 'hello nanjiu';
                }
            }
            fn();  // undefined
                    
                在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，
                相当于覆盖了外层的tmp，所以打印结果为undefined。
                var tmp = 'hello nan jiu';
                
                for (var i = 0; i < tmp.length; i++) {
                    console.log(tmp[i]);
                }
                console.log(i); // 13
            ​
            由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来13。
            总结      
            解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间
            声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行
            函数是一等公民，当函数声明与变量声明冲突时，变量提升时函数优先级更高，会忽略同名的变量声明
        服务端渲染
            解释：服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，我们在 html 源文件里也能找到。有了服务端渲染，当请求用户页面时，返回的body里已经有了首屏的html结构，之后结合css显示出来。
    
            优点：  
                ①首屏渲染快(关键性问题)：相比于加载单页应用，我只需要加载当前页面的内容，而不需要像 React 或者 Vue 一样加载全部的 js 文件；
                ②SEO(搜索引擎)优化：不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本
                ③可以生成缓存片段、节能；
            ​
            缺点：用户体验较差，不容易维护、通常前端改了部分html或者css，后端也需要改；
            ​
            使用场景：vue全家桶或者react全家桶，都是推荐通过服务端渲染来实现路由的。

        event loop event queue
            在js中我们经常需要同时执行很多件任务，例如，定时器，事件。异步数据，而js是单线程的原因不能同时进行很多件事情，必须等上一件任务执行完了才会执行下一个，需要通过Event Loop 来处理很多任务的执行

            因为js是单线程的，代码执行的时候，将不同的函数执行上下文压入到栈中进行有序的执行，
            在执行同步代码的时候，如果遇到了异步事件，js引擎并不会一直等待其返回结果，就是将它挂起，继续执行栈中其他的任务
            当同步任务执行完了，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。
            任务队列分为的宏任务队列和微任务队列，当前的执行栈中执行完，js引擎会首先判断微任务队列是否有任务可以执行有的话，放到栈中执行。
            当微任务队列中的任务执行完了再去判断宏任务中的队列。


            为什么会有任务队列呢？
            还是因为 javascript 单线程的原因，单线程，就意味着一个任务一个任务的执行，
            执行完当前任务，执行下一个任务，这样也会遇到一个问题，就比如说，要向服务端通信，加载大量数据，如果是同步执行，
            js 主线程就得等着这个通信完成，然后才能渲染数据，为了高效率的利用cpu, 就有了同步任务和异步任务之分。


        同步和异步的区别？各举一个js例子

            概念：
                同步：上一件事情没有完成，继续处理上一件事情，只有上一件事情完成了，才会做下一件事情
                异步： 规划要做一件事情,如果是异步事情，不是当前立马去执行这件事情，需要等一定的时间，这样的话，我们不会等着他执行，而是继续执行下面的操作
                对于写程序，同步往往会阻塞，没有数据过来，我就等着，异步则不会阻塞，没数据来我干别的事，有数据来去处理这些数据。
                同步案例：for循环语句，alert(),console.log()等 js大部分都是同步编程
                异步案例：所有定时器，ajax异步请求，所有的事件绑定都是异步;
                举例子
                同步，就是实时处理（如打电话），比如服务器一接收客户端请求，马上响应，这样客户端可以在最短的时间内得到结果，但是如果多个客户端，或者一个客户端发出的请求很频繁，服务器无法同步处理，就会造成涌塞。
                同步如打电话，通信双方不能断（我们是同时进行，同步），你一句我一句，这样的好处是，对方想表达的信息我马上能收到，但是，我在打着电话，我无法做别的事情。
                异步，就是分时处理（如收发短信），服务器接收到客户端请求后并不是立即处理，而是等待服务器比较空闲的时候加以处理，可以避免涌塞。

8、Bom浏览器对象模型
   js操作BOM
        浏览器对象模型（BOM ：Browser Object Model）是JavaScript的组成之一，它提供了独立于内容与浏览器窗口进行交互的对象，使用浏览器对象模型可以实现与HTML的交互。它的作用是将相关的元素组织包装起来，提供给程序设计人员使用，从而降低开发人员的劳动量，提高设计Web页面的能力。

        window : alert() , prompt() , confirm() , setInterval() , clearInterval() , setTimeout() , clearTimeout() ;

        history : go(参数) , back() , foward() ;

        location : herf属性.

        1、window.location.href = '你所要跳转到的页面'; 2、window.open('你所要跳转到的页面’); 2、window.history.back(-1):返回上一页 4、window.history.go(-1/1):返回上一页或下一页五、 3、history.go("baidu.com")；
        4、window.print() 直接掉用打印窗口可以用来拔面试题。

        说出5个以上Math对象中的成员。
        Math.PI 圆周率

        Math.floor() 向下取整

        Math.ceil() 向上取整

        Math.round() 四舍五入版 就近取整

        Math.abs() 绝对值

        Math.max()/Math.min() 求最大和最小值

        Math.random() 获取范围在[0,1)内的随机值

        setTimeout与setInterval区别与机制
        setTimeout()和setInterval()经常被用来处理延时和定时任务。

        setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式

        setInterval()则可以在每隔指定的毫秒数循环调用函数或表达式，直到clearInterval把它清除。

        机制：
        
        因为js是单线程的。浏览器遇到setTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的
        待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码
        window的onload事件和domcontentloaded
        window.onload：当一个资源及其依赖资源已完成加载时，将触发onload事件。 document.onDOMContentLoaded：当初始的HTML文档被完全加载和解析完成之后， DOMContentLoaded事件被触发，而无需等待样式表、图像和子框架的完成加载。 区别： ①onload事件是DOM事件，onDOMContentLoaded是HTML5事件。 ②onload事件会被样式表、图像和子框架阻塞，而onDOMContentLoaded不会。 ③当加载的脚本内容并不包含立即执行DOM操作时，使用onDOMContentLoaded事件是个更好的选择，会比onload事件执行时间更早。

        cookies，sessionStorage 和 localStorage 的区别?
        cookie：一个大小不超过4K的小型文本数据，一般由服务器生成，可以设置失效时间；若没有设置时间，关闭浏览器cookie失效，若设置了 时间，cookie就会存放在硬盘里，过期才失效，每次http请求，header都携带cookie

        localStorage：5M或者更大，永久有效，窗口或者浏览器关闭也会一直保存，除非手动永久清除或者js代码清除，因此用作持久数据，不参与和服务器的通信

        sessionStorage关闭页面或浏览器后被清除。存 放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。

        location、之lnavigator和history
        location 对象存储了当前文档位置（URL）相关的信息，简单地说就是网页地址字符串。使用 window 对象的 location 属性可以访问。

        href会重新定位到一个URL，hash会跳到当前页面中的anchor名字的标记(如果有)，而且页面不会被重新加载

        history
        window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中） 访问过的 URL。

        history.back 可以后退一个网页

        history.go 可以前进后退 1前进 -1 后退

        history.forward  前进

        navigator对象
        window.navigator`对象包含有关浏览器的信息，可以用它来查询一些关于运行当前脚本的应用程序的相关信息
    
        navigator.appCodeName 只读,任何浏览器中，总是返回 'Gecko'。该属性仅仅是为了保持兼容性。

        navigator.appName 只读,返回浏览器的官方名称。不要指望该属性返回正确的值。

        navigator.appVersion 只读,返回一个字符串，表示浏览器的版本。不要指望该属性返回正确的值。

        navigator.platform 只读,返回一个字符串，表示浏览器的所在系统平台。

        navigator.product 只读,返回当前浏览器的产品名称（如，"Gecko"）。

        navigator.userAgent 只读,返回当前浏览器的用户代理字符串（user agent string）

        DOM文档对象模型
        DOM是 document 用来表示文档中对象的标准模型，他是由节点和对象组成的结构集合。在浏览器解析HTML标签时，会构建一个DOM树结构。

        操作说明书

        拿到指定节点``
        var id = document.getElementById("id");  //返回带有指定id的元素
        var name = document.getElementByTagName("li"); //返回带有指定标签的元素
        var class = document.getElementByClassName("class"); //返回带有包含执行类名的所有元素节点列表。`
        创建DOM节点
        var node = document.createElement("div");
        var attr = document.createAttribute("class");
        var text = document.createTextNode("菜呀菜");`
        插入DOM节点
        node.appendChild(text) //插入新的子节点
        node.insertBefore(pre,child) //在node元素内child前加入新元素`
        删除DOM节点
        node.removeChild(text) //从父元素删除子元素节点
        修改DOM节点
        node.setAttribute("class","name") //修改设置属性节点
        node.replaceChild(pre,child)  //父节点内新子节点替换旧子节点`
        常用DOM属性
        node.innerHtml  //获取/替换元素内容
        node.parentNode  //元素节点的父节点
        node.parentElement  //元素节点的父元素节点（一般与Node节点相同）
        node.firstChild  //属性的第一个节点
        node.lastChild   //属性的最后一个节点
        node.nextSibling //节点元素后的兄弟元素（包括回车，空格，换行）
        node.nextElementSibling //节点元素后的兄弟元素节点
        node.previousSibling //获取元素的上一个兄弟节点（元素，文本，注释）
        node.previousElementSibling //获取元素的上一个兄弟节点（只包含元素节点）
        node.childNodes  //元素节点的子节点（空格，换行默认为文本节点）
        node.children    //返回当前元素的所有元素节点
        node.nodeValue   //获取节点值
        node.nodeName    //获取节点名字
        node.attributes  //元素节点的属性节点
        node.getAttribute("name")  //元素节点的某个属性节点
        node.style.width = "200px"  //设置css样式`

9、dom文档对象模型
    常用的api
    offset、client、scroll的用法
10、拓展
       什么是函数式编程? 命令式编程？声明式编程？
            声明式编程：专注于”做什么”而不是”如何去做”。在更高层面写代码，更关心的是目标，而不是底层算法实现的过程。 如：css, 正则表达式，sql 语句，html, xml…

            命令式编程(过程式编程) : 专注于”如何去做”，这样不管”做什么”，都会按照你的命令去做。解决某一问题的具体算法实现。

            如： for（）

            函数式编程：把运算过程尽量写成一系列嵌套的函数调用。

            如 ： forEach（）

            iframe的优缺点有哪些？
            优点：
                ①iframe能够原封不动的把嵌入的网页展现出来；
                ②如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。
                ③网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。
                ④如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。
            ​
            缺点：
                ①会产生很多页面不易管理；
                ②iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。
                ③代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。
                ④很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。
                ⑤iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。

            如何让(a == 1 && a == 2 && a == 3)的值为true？
            " == "操作符在左右数据不一致的时候，会先进行隐式转换，该值意味着不是基本数据类型，
            因为如果a是null或者undefined、bool类型都不可能返回true；可以推测a是复杂数据类型。
            ​
            方法一：数组的 toString 接口默认调用数组的 join 方法，重新 join 方法
            ​
            let a = [1,2,3];
            a.join = a.shift;
            console.log(a == 1 && a == 2 && a == 3) //true
            ​
            ​
            方法二：利用数据劫持(Proxy/Object.definedProperty)
            ​
            let i = 1;
            let a = new Proxy({},{
                i:1,
                get:function(){
                    return () => this.i++
                }
            });
            console.log(a == 1 && a == 2 && a == 3);

            为什么0.1+0.2 ! == 0.3，如何让其相等
            在开发过程中遇到类似这样的问题：
            
            let n1 = 0.1, n2 = 0.2
            console.log(n1 + n2)  // 0.30000000000000004
            
            这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：
            
            (n1 + n2).toFixed(2) // 注意，toFixed为四舍五入

            toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？
            
            计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和
## js的大山

11、使用面向对象编程时，new关键字做了什么
12、es5和es6的继承
13、js的原型和原型链
14、js创建对象的几种方法
15、什么设计模式
16、面向过程、面向对象和面向过程的区别