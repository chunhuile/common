## 面试题3
    1、react如何捕获异常
        有几种方法：
            try/catch
            onError
            以及react官网的16版的ErrorBoundry、15版的unstable_handlerError
                可捕获子组件的渲染
                生命周期函数
                构造函数

    2、使用redux有哪些原则
        原则：
            单一的数据源
            只读的state
            纯函数的组件可以修改数据

        拓展：
            什么时候使用
                略
            reducer时一个函数，接受当前的state和一个action对象，必要时决定如何更新状态，并返回新状态。reducer必须符合以下规则：
                近使用state和action参数计算新的状态值
                禁止修改state
                禁止任何异步操作、依赖随机值或导致其他副作用代码
            reducer遵守上述规则的原因：
                redux的目标之一是代码可预测
                如果一个函数依赖于自身之外的变量，或者随机行为，你永远不能知道发生了什么
                如果一个函数mutate了其他对象，比如它的参数。
        坚持原则的原因：
            会导致bug
            更难理解的状态更新方式和原因
            编写测试变得困难
            打破正确使用的“时间旅行调试”的能力
            违背redux的预期精神和使用模式

    3、react中构建组件的方式有哪些？
        类组件和函数组件
        构建组件的方式有3种：
            函数式创建
            react.createClass()
            react.component（）创建

        区别：
            createClass()创建方式冗余，不建议使用
            而函数式创建和类组件的创建的区别主要在于需要创建的组件是否需要为有状态组件：
                对于一些无状态组件创建，建议使用函数式创建的方式
                react hooks的出现，函数式组件创建的组件通过hooks方法也能成为有状态组件，再加上目前推崇的函数式编程，所以这里建议都使用函数式的方式来创建组件

    4、state和props有什么区别？
        相同点：
            都是js对象
            都用于保存信息
            props和state都能触发渲染更新
        区别：
            props是外部传递给组件的，而state是在组件内被组件自己管理的，一般在constructor中初始化
            props在组件内不是不可修改的，但是state在组件内部可以进行修改
            state是多变的，可以修改

    5、react的懒加载的实现原理是什么？
        使用.lazy配合code splitting，只有当组件被加载，对应的资源才会导入，从而达到懒加载的效果


    6、react有哪些性能优化的地方？
        减少不必要的嵌套
        不要在渲染函数汇总进行必要的计算
        虚拟列表
            常用于：
                无限滚动列表
                无限切换的日历或是轮播图
                大数据量或是无限嵌套的树
                聊天窗、数据流、时间轴
        惰性渲染
        合适的样式渲染方案
        避免重新渲染
        简化props
        不变的事件处理器
        不可变数据
        简化state
        使用recompose精细化比对
        精细化渲染
        响应式数据的精细化渲染
        不要滥用context

    7、constructor中的super和props参数一起使用的目的是什么？

    8、为什么不能直接使用this.state改变数据？
        因为不能重新触发render
        
    9、react如果绑定事件使用匿名函数有什么影响？
        略
    10、react的虚拟dom是如何实现的？
        定义：react对于虚拟dom给了一个概念：虚拟dom是真实dom结构映射的数据结构

    11、为什么react的vm可以提高性能？

        因为vm并不是操作真实dom，通过diff算法可以避免一些不变更的dom操作，从而提高了性能

    12、react hooks带来了什么便利？
        在没有hooks之前，使用函数定义的组件中，不能使用sate、各种生命周期钩子类组件的特性。在16.8版本后，推出了hooks，通过hooks我们可以再函数定义的组件中使用类组件的特性
        好处：
            跨组件复用
            相比而言，类组件的实现更为复杂：
                不同的生命周期会使逻辑变得分散且混乱，不易于维护和管理
                时刻需要关注this的指向问题
                代码复用价值极高，高阶组件的使用经常会使整个组件树变得臃肿
        注意：
            避免在循环/条件判断/嵌套函数中调用hooks，保证调用顺序的稳定
            不能在useEffect中使用useState，react会报错提示
            类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存

    13、常见的hook？
        状态钩子（useState）
        useEffect(生命周期钩子)
        useContext:获取context对象
        useCallback：缓存回调函数
        useMemo：用于缓存
        useRef:获取组件的真实节点 
    14、使用react hooks有什么优势？
        是18版本后引入的新特性，允许在写class的情况下操作state和react的新特性

        解决的问题是状态共享，是继render-props和high-order component之后的第三种状态共享方案，不会产生jsx嵌套地狱问题。
        这个状态指的是状态逻辑，所以称为状态逻辑复用会更为恰当，因为只会共享数据处理逻辑，不会共享数据本身

    15、介绍下react中的diff算法？
        三个规律：
            dom节点的跨层移动的操作特别少，可以忽略不计
            拥有相同类的两个组件将会生成相似的树形结构
            对于同一层级的一组子节点，可以通过唯一的id进行区分

        tree diff
        略
        component diff
            略
        element diff
        略
    16、react fiber是什么？
        略
    17、不同版本的react都做了哪些优化？
        16版给三个生命周期添加前缀
        18版 引入fiber架构，引入静态函数get fromprops，删除三个生命州区
    18、state和props有什么区别？
        略
    19、redux中的异步的请求如何处理？
        略

    20、mobx和redux的区别？
        略